---
author: komori-n
categories:
  - 技術解説
date: 2023-09-18T16:00:32+09:00
tags:
  - 数学
keywords:
  - 線形走査法
  - ガベージコレクション
  - ハッシュテーブル
  - 最適化問題
title: 線形走査法ハッシュテーブルにおける最適なガベージコレクション戦略
relpermalink: blog/optimized-linear-probing
url: blog/optimized-linear-probing
description: 線形走査法（linear probing）を用いるハッシュテーブルにおいて、
  どのような戦略でガベージコレクションを行うのが最適であるかを考察する。
draft: true
---

{{< katex >}}

線形走査法（linear probing）を用いるハッシュテーブルにおいて、
どのような戦略でガベージコレクションを行うのが最適であるかを考察する。

## 背景

ハッシュテーブル（hash table）は、キーのハッシュ値をもとに
値の挿入や検索を高速に行うことができるデータ構造である。
ハッシュテーブルでは、ハッシュ値が衝突したときの処理方法として、
連鎖法と開番地法の2種類の方法が存在する。

本ページでは、開番地法の実装方法の一つである
**線形走査法（linear probing）** について扱う。
線形走査法は1954年に開発された方法で、ハッシュ値が衝突したとき、
直後の要素を空きエントリが見つかるまで探索する方法である。
とてもシンプルな実装方法で、ハッシュ使用率が低いときはとても高速に動作するため、
簡易的なハッシュテーブル実装としてしばしば用いられる[^kh]。

[^kh]: KomoringHeightsでは、regular_table（通常の置換表）にて線形走査法のハッシュテーブルが使用されている

以下では、ハッシュテーブルに格納可能な要素数の最大値（配列サイズ）を $N$ とする。

ハッシュテーブルでは、ハッシュ使用率が高くなるほど要素の挿入や検索に
時間がかかることが知られている。探索するキーのハッシュ値が一様乱数に従うとき、
線形探査法のハッシュテーブル対し、 $k$ 個目の要素を挿入する際に必要な
ハッシュ値同士の比較回数の期待値 $M(N, k)$ の近似値は、

\\begin{align}
M(N, k) \simeq \frac{1}{2}\left(
1 + \frac{1}{(1-\rho)^2}
\right)
\\end{align}

となる[^expectation]。ただし、$\rho := (k - 1)/N$ は挿入直前のハッシュ使用率である。なお、
上で示した式はエントリの挿入に必要なハッシュ比較回数の期待値だが、
検索に必要な比較回数の期待値も $M(N, k)$ に一致する。

[^expectation]: Knuth, Donald E. "Notes on “open” addressing." Unpublished memorandum (1963): 11-97.

式 $(1)$ が示す通り、線形探査法では、ハッシュ使用率 $\rho$ が増えれば増えるほど、
挿入や探索に必要な計算量が大幅に増加してしまう。そのため、
線形探査法を高速に動作させるためには、ハッシュ使用率を低く保つための仕組みを
導入する必要がある。

## 本題

ハッシュ使用率を下げる方法として、ガベージコレクション（GC）と呼ばれる方法が
知られている。これは、ハッシュ使用率があるしきい値 $\rho_2$ 以上になったら、
エントリ削除を行うことでハッシュ使用率を $\rho_1$ （$0\leq \rho_1 < \rho_2<1$）へと
下げる方法である。

GCにおいて、$\rho_1$ はメモリ効率と実行速度の両方を左右するパラメータである。
$\rho_1$ が小さいほどGCにおいて多くのエントリが削除されるため、
ハッシュテーブル内に残るエントリの数は少なくなる。
一方、$\rho_1$ が大きいほどハッシュテーブルの挿入や検索に必要な
計算量が増加してしまう。
このように、$\rho_1$ の値は、空間と時間のトレードオフの関係を考慮して
決めなければならない。

さて、GC後のハッシュ使用率 $\rho_1$ が予め与えられているとき、
$\rho_2$ をいくつに設定すると挿入や検索の計算量を最小化できるのかを求めたい。
$\rho_2$ の値が小さすぎると、頻繁にGCを行わなければならなくなる。
一方、$\rho_2$ の値が大きすぎると、線形走査法で確認すべきエントリ数が増え、
エントリの挿入や検索に時間がかかってしまう。
つまり、$\rho_2$ は大きすぎても小さすぎても良くない値であり、
区間 $(\rho_1, 1)$ の間に最適値があると考えられる。

以下のような状況設定で $\rho_2$ の最適値を求めたい。

- エントリの挿入や検索に使用するキーは一様乱数に従う
- エントリの挿入 $1$ 回に対し、検索が $a-1$ 回発生する
- 1回のGCにおけるハッシュ値の比較回数は $2N$ 回である
- 挿入1回あたりに平均化したハッシュ値の比較回数の期待値を最小化ように $\rho_2$ を決める

式で表すと、

\\begin{align}
\min*{\rho_2} \frac{1}{N(\rho_2 - \rho_1)} \left(
2N + \frac{a}{2} \sum*{k=\lfloor N \rho_1 \rfloor}^{\lfloor N \rho_2 \rfloor}
\left(
1 + \frac{1}{(1 - \rho)^2}
\right)
\right)
\\end{align}

となる。
この最小化問題に対し、和を積分で置き換えて近似し、式を整理すると
近似した最小化問題

\\begin{align}
\min\_{\rho_2} \frac{1}{\rho_2 - \rho_1} \left(
2 + \frac{a}{2} \left(
\rho_2 - \rho_1 + \frac{1}{1 - \rho_2} - \frac{1}{1 - \rho_1}
\right)
\right)
\\end{align}

が得られる。

式 (3) の近似した最小化問題に対し、いくつかの $\rho_1, a$ を与えて
求解を行った。求解結果を以下に示す。

**表1: $\rho_2$の最適値 ★もう少し各 ★再計算**
||$\rho_1=0.1$|$\rho_1=0.2$|$\rho_1=0.3$|$\rho_2=0.4$|$\rho_2=0.5$|
|--:|--:|--:|--:|--:|--:|
|$a=1$|0.6157|0.6477|0.6794|0.7137|0.7500|
|$a=3$|0.4928|0.5377|0.5841|0.6325|0.6830|
|$a=5$|0.4375|0.4890|0.5422|0.5973|0.6545|
|$a=7$|0.4028|0.4588|0.5163|0.5757|0.6371|
|$a=9$|0.3781|0.4373|0.4980|0.5605|0.6250|

<br>

**表2: 最適な$\rho_2$を与えたときの目的関数値 ★再計算**
||$\rho_1=0.1$|$\rho_1=0.2$|$\rho_1=0.3$|$\rho_2=0.4$|$\rho_2=0.5$|
|--:|--:|--:|--:|--:|--:|
|$a=1$|4.3847|5.0077|5.8637|7.0985|9.0000|
|$a=3$|6.8318|8.0170|9.6722|12.1038|15.9282|
|$a=5$|8.9012|10.5757|12.9301|16.4152|21.9443|
|$a=7$|10.8144|12.9479|15.9602|20.4397|27.5830|
|$a=9$|12.6357|15.2105|18.8564|24.2954|33.0000|

これらの表より、$\rho_1$ や $a$ の値に応じて、$\rho_2$ の最適値や目的関数値が大きく変化することがわかる。

なお、実用上は、エントリの検索に用いるキーが一様分布に従うことはなく、
テーブル内に存在するキーが検索に用いられる可能性が高い。
そのため、一様分布の仮定を置いて求めた $\rho_2$ の最適値をそのまま用いるのではなく、
少し小さな値を用いたほうがパフォーマンスが向上する可能性がある。

## 数値実験

上記の解析結果を数値的に確かめるために、数値実験を行った。

{{< github repo="komori-n/kh-benchmarks" >}}

パラメータ $a=6, \rho_1=0.3$ に対し、$\rho_2$ の値を様々に変えたときの実行時間を
測定した。測定結果のグラフを以下に示す。

{{< chart >}}
type: 'line',
data: {
labels: [0.30957, 0.319336, 0.329102, 0.338867, 0.348633, 0.358398, 0.368164,
0.37793, 0.387695, 0.397461, 0.407227, 0.416992, 0.426758, 0.436523,
0.446289, 0.456055, 0.46582, 0.475586, 0.485352, 0.495117, 0.504883,
0.514648, 0.524414, 0.53418, 0.543945, 0.553711, 0.563477, 0.573242,
0.583008, 0.592773, 0.602539, 0.612305, 0.62207, 0.631836, 0.641602,
0.651367, 0.661133, 0.670898, 0.680664, 0.69043, 0.700195, 0.709961,
0.719727, 0.729492, 0.739258, 0.749023, 0.758789, 0.768555, 0.77832,
0.788086, 0.797852, 0.807617, 0.817383, 0.827148, 0.836914, 0.84668,
0.856445, 0.866211, 0.875977, 0.885742, 0.895508, 0.905273, 0.915039,
0.924805, 0.93457, 0.944336, 0.954102, 0.963867, 0.973633, 0.983398,
0.993164],
datasets: [{ label: "間違い個数",
data: [534.225, 313.5, 239.3, 205.556, 178.825, 163.912, 153.875, 145.838,
140.058, 134.947, 130.559, 128.171, 133.188, 125.55, 127.367, 121.236,
120.46, 121.129, 119.303, 117.22, 115.86, 115.573, 115.233, 115.058,
114.398, 113.791, 115.25, 114.06, 114.459, 115.162, 113.257, 113.593,
113.155, 111.915, 113.808, 113.715, 111.505, 111.503, 111.114, 111.336,
108.769, 111.478, 111.658, 112.547, 113.341, 114.075, 114.226, 113.399,
114.624, 117.559, 113.677, 114.96, 116.18, 117.05, 122.245, 118.314,
120.812, 121.594, 122.038, 124.42, 126.093, 129.291, 132.382, 136.552,
145.575, 165.884, 168.121, 179.479, 200.756, 233.693, 289.199],
backgroundColor: [
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(255, 0, 0, 0.8)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)",
"rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)", "rgba(0, 0, 0, 0)"]
},
]
},
options: { scales: {
x: { display: true, title: { display: true, text: "ハッシュ使用率（ρ2）" }},
y: { display: true, title: { display: true, text: "挿入1回あたりにかかった計算時間（ns）" }}
}, plugins: { legend: { display: false },
title: {display: true, text: "各ρ2において、挿入1回あたりにかかった計算時間（a=6、ρ1=0.3）"}}}
{{< /chart >}}

理論的に予測した通り、挿入1回あたりの実行時間は下に凸なグラフになった。特に、
$\rho_2=0.700$ のときに挿入1回あたりの実行時間は最小となり、その値は 108.769 nsだった。
ただし、グラフから読み取れる通り、$\rho_2 \in [0.5, 0.8]$ の区間は
実行時間にあまり差がなく、実用上は $\rho_2$ の値をもう少し大きくしても問題ないと考える。

## まとめ

本ページでは、線形走査法を用いるハッシュテーブルにおいて、
GCを行うタイミングやGCで削除するエントリ数についての考察を行った。
比較回数の期待値を近似した最小化問題を解くことで、
これらのパラメータの最適値を求めることができた。
また、数値実験を行い、GCタイミングはあまり重要ではないことを確認した。
